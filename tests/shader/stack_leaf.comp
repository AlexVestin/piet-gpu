// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense

// The main phase for the stack monoid

#version 450

// Currently N_SEQ is hardcoded at 1
#define LG_WG_SIZE 9
#define WG_SIZE (1 << LG_WG_SIZE)
#define PART_SIZE WG_SIZE

layout(local_size_x = WG_SIZE, local_size_y = 1) in;

// The bicyclic monoid
struct Bic {
    uint a;
    uint b;
};

Bic bic_combine(Bic x, Bic y) {
    uint m = min(x.b, y.a);
    return Bic(x.a + y.a - m, x.b + y.b - m);
}

layout(binding = 0) readonly buffer InBuf {
    uint[] inbuf;
};

layout(binding = 1) readonly buffer BicBuf {
    Bic[] bicbuf;
};

layout(binding = 2) readonly buffer StackBuf {
    uint[] stack;
};

layout(binding = 3) buffer OutBuf {
    uint[] outbuf;
};

shared Bic sh_bic[WG_SIZE * 2 - 2];
shared uint sh_stack[PART_SIZE];

void main() {
    uint th = gl_LocalInvocationID.x;
    // materialize stack up to start of this partition
    // start with reverse scan of bicyclic semigroup
    Bic bic = Bic(0, 0);
    if (th < gl_WorkGroupID.x) {
        bic = bicbuf[th];
    }
    sh_bic[th] = bic;
    for (uint i = 0; i < LG_WG_SIZE; i++) {
        barrier();
        if (th + (1u << i) < WG_SIZE) {
            Bic other = sh_bic[th + (1u << i)];
            bic = bic_combine(bic, other);
        }
        barrier();
        sh_bic[th] = bic;
    }
    barrier();

    // binary search in stack
    uint sp = PART_SIZE - 1 - th;
    uint ix = 0;
    for (uint i = 0; i < LG_WG_SIZE; i++) {
        uint probe = ix + (uint(PART_SIZE / 2) >> i);
        if (sp < sh_bic[probe].b) {
            ix = probe;
        }
    }
    // ix is the largest value such that sp < sh_bic[ix].b (if any)
    uint b = sh_bic[ix].b;
    if (sp < b) {
        sh_stack[th] = stack[ix * PART_SIZE + b - sp - 1];
    }
    barrier();

    // Do tree reduction of bicyclic semigroups (up-sweep)
    uint inp = inbuf[gl_GlobalInvocationID.x];
    bic = Bic(1 - inp, inp);
    sh_bic[th] = bic;
    uint inbase = 0;
    for (uint i = 0; i < LG_WG_SIZE - 1; i++) {
        uint outbase = 2 * WG_SIZE - (1u << (LG_WG_SIZE - i));
        barrier();
        if (th < (1u << (LG_WG_SIZE - 1 - i))) {
            sh_bic[outbase + th] = bic_combine(sh_bic[inbase + th * 2], sh_bic[inbase + th * 2 + 1]);
        }
        inbase = outbase;
    }
    barrier();

    // Search for predecessor node.
    ix = th;
    uint j = 0;
    bic = Bic(0, 0);
    while (j < LG_WG_SIZE) {
        uint base = 2 * WG_SIZE - (2u << (LG_WG_SIZE - j));
        if (((ix >> j) & 1) != 0) {
            Bic test = bic_combine(sh_bic[base + (ix >> j) - 1], bic);
            if (test.b > 0) {
                break;
            }
            bic = test;
            ix -= 1u << j;
        }
        j++;
    }
    if (ix > 0) {
        while (j > 0) {
            j--;
            uint base = 2 * WG_SIZE - (2u << (LG_WG_SIZE - j));
            Bic test = bic_combine(sh_bic[base + (ix >> j) - 1], bic);
            if (test.b == 0) {
                bic = test;
                ix -= 1u << j;
            }
        }
    }
    // ix is the smallest value such that reduce(ix..th).b == 0
    // bic is reduce(ix..th)

    // Generate output
    uint outp;
    if (ix > 0) {
        outp = gl_WorkGroupID.x * PART_SIZE + ix - 1;
    } else {
        outp = sh_stack[PART_SIZE - 1 - bic.a];
    }
    outbuf[gl_GlobalInvocationID.x] = outp;
}
